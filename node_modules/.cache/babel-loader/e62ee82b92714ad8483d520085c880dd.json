{"ast":null,"code":"\"use strict\";\n/* eslint-disable */\n\n/**\r\n* Ratelimit requests and release in sequence\r\n* @prop {Number} limit How many tokens the bucket can consume in the current interval\r\n* @prop {Number} remaining How many tokens the bucket has left in the current interval\r\n* @prop {Number} reset Timestamp of next reset\r\n* @prop {Boolean} processing Whether the queue is being processed\r\n*/\n\nclass SequentialBucket {\n  /**\r\n  * Construct a SequentialBucket\r\n  * @arg {Number} tokenLimit The max number of tokens the bucket can consume per interval\r\n  * @arg {Object} [latencyRef] An object\r\n  * @arg {Number} latencyRef.latency Interval between consuming tokens\r\n  */\n  constructor(limit, latencyRef = {\n    latency: 0\n  }) {\n    this.limit = this.remaining = limit;\n    this.resetInterval = 0;\n    this.reset = 0;\n    this.processing = false;\n    this.latencyRef = latencyRef;\n    this._queue = [];\n  }\n  /**\r\n  * Queue something in the SequentialBucket\r\n  * @arg {Function} func A function to call when a token can be consumed. The function will be passed a callback argument, which must be called to allow the bucket to continue to work\r\n  */\n\n\n  queue(func, short) {\n    if (short) {\n      this._queue.unshift(func);\n    } else {\n      this._queue.push(func);\n    }\n\n    this.check();\n  }\n\n  check(override) {\n    if (this._queue.length === 0) {\n      if (this.processing) {\n        clearTimeout(this.processing);\n        this.processing = false;\n      }\n\n      return;\n    }\n\n    if (this.processing && !override) {\n      return;\n    }\n\n    const now = Date.now();\n    const offset = this.latencyRef.latency + (this.latencyRef.offset || 0);\n\n    if (!this.reset) {\n      this.reset = now - offset;\n      this.remaining = this.limit;\n    } else if (this.reset < now - offset) {\n      this.reset = now - offset + (this.resetInterval || 0);\n      this.remaining = this.limit;\n    }\n\n    this.last = now;\n\n    if (this.remaining <= 0) {\n      this.processing = setTimeout(() => {\n        this.processing = false;\n        this.check(true);\n      }, Math.max(0, (this.reset || 0) - now) + offset);\n      return;\n    }\n\n    --this.remaining;\n    this.processing = true;\n\n    this._queue.shift()(() => {\n      if (this._queue.length > 0) {\n        this.check(true);\n      } else {\n        this.processing = false;\n      }\n    });\n  }\n\n}\n\nmodule.exports = SequentialBucket;","map":{"version":3,"sources":["C:/Users/Romas/astro/node_modules/discord-oauth2/lib/eris/util/SequentialBucket.js"],"names":["SequentialBucket","constructor","limit","latencyRef","latency","remaining","resetInterval","reset","processing","_queue","queue","func","short","unshift","push","check","override","length","clearTimeout","now","Date","offset","last","setTimeout","Math","max","shift","module","exports"],"mappings":"AAAA;AAEA;;AAEA;;;;;;;;AAOA,MAAMA,gBAAN,CAAuB;AACnB;;;;;;AAMAC,EAAAA,WAAW,CAACC,KAAD,EAAQC,UAAU,GAAG;AAACC,IAAAA,OAAO,EAAE;AAAV,GAArB,EAAmC;AAC1C,SAAKF,KAAL,GAAa,KAAKG,SAAL,GAAiBH,KAA9B;AACA,SAAKI,aAAL,GAAqB,CAArB;AACA,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKC,UAAL,GAAkB,KAAlB;AACA,SAAKL,UAAL,GAAkBA,UAAlB;AACA,SAAKM,MAAL,GAAc,EAAd;AACH;AAED;;;;;;AAIAC,EAAAA,KAAK,CAACC,IAAD,EAAOC,KAAP,EAAc;AACf,QAAGA,KAAH,EAAU;AACN,WAAKH,MAAL,CAAYI,OAAZ,CAAoBF,IAApB;AACH,KAFD,MAEO;AACH,WAAKF,MAAL,CAAYK,IAAZ,CAAiBH,IAAjB;AACH;;AACD,SAAKI,KAAL;AACH;;AAEDA,EAAAA,KAAK,CAACC,QAAD,EAAW;AACZ,QAAG,KAAKP,MAAL,CAAYQ,MAAZ,KAAuB,CAA1B,EAA6B;AACzB,UAAG,KAAKT,UAAR,EAAoB;AAChBU,QAAAA,YAAY,CAAC,KAAKV,UAAN,CAAZ;AACA,aAAKA,UAAL,GAAkB,KAAlB;AACH;;AACD;AACH;;AACD,QAAG,KAAKA,UAAL,IAAmB,CAACQ,QAAvB,EAAiC;AAC7B;AACH;;AACD,UAAMG,GAAG,GAAGC,IAAI,CAACD,GAAL,EAAZ;AACA,UAAME,MAAM,GAAG,KAAKlB,UAAL,CAAgBC,OAAhB,IAA2B,KAAKD,UAAL,CAAgBkB,MAAhB,IAA0B,CAArD,CAAf;;AACA,QAAG,CAAC,KAAKd,KAAT,EAAgB;AACZ,WAAKA,KAAL,GAAaY,GAAG,GAAGE,MAAnB;AACA,WAAKhB,SAAL,GAAiB,KAAKH,KAAtB;AACH,KAHD,MAGO,IAAG,KAAKK,KAAL,GAAaY,GAAG,GAAGE,MAAtB,EAA8B;AACjC,WAAKd,KAAL,GAAaY,GAAG,GAAGE,MAAN,IAAgB,KAAKf,aAAL,IAAsB,CAAtC,CAAb;AACA,WAAKD,SAAL,GAAiB,KAAKH,KAAtB;AACH;;AACD,SAAKoB,IAAL,GAAYH,GAAZ;;AACA,QAAG,KAAKd,SAAL,IAAkB,CAArB,EAAwB;AACpB,WAAKG,UAAL,GAAkBe,UAAU,CAAC,MAAM;AAC/B,aAAKf,UAAL,GAAkB,KAAlB;AACA,aAAKO,KAAL,CAAW,IAAX;AACH,OAH2B,EAGzBS,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,CAAC,KAAKlB,KAAL,IAAc,CAAf,IAAoBY,GAAhC,IAAuCE,MAHd,CAA5B;AAIA;AACH;;AACD,MAAE,KAAKhB,SAAP;AACA,SAAKG,UAAL,GAAkB,IAAlB;;AACA,SAAKC,MAAL,CAAYiB,KAAZ,GAAoB,MAAM;AACtB,UAAG,KAAKjB,MAAL,CAAYQ,MAAZ,GAAqB,CAAxB,EAA2B;AACvB,aAAKF,KAAL,CAAW,IAAX;AACH,OAFD,MAEO;AACH,aAAKP,UAAL,GAAkB,KAAlB;AACH;AACJ,KAND;AAOH;;AAlEkB;;AAqEvBmB,MAAM,CAACC,OAAP,GAAiB5B,gBAAjB","sourcesContent":["\"use strict\";\r\n\r\n/* eslint-disable */\r\n\r\n/**\r\n* Ratelimit requests and release in sequence\r\n* @prop {Number} limit How many tokens the bucket can consume in the current interval\r\n* @prop {Number} remaining How many tokens the bucket has left in the current interval\r\n* @prop {Number} reset Timestamp of next reset\r\n* @prop {Boolean} processing Whether the queue is being processed\r\n*/\r\nclass SequentialBucket {\r\n    /**\r\n    * Construct a SequentialBucket\r\n    * @arg {Number} tokenLimit The max number of tokens the bucket can consume per interval\r\n    * @arg {Object} [latencyRef] An object\r\n    * @arg {Number} latencyRef.latency Interval between consuming tokens\r\n    */\r\n    constructor(limit, latencyRef = {latency: 0}) {\r\n        this.limit = this.remaining = limit;\r\n        this.resetInterval = 0;\r\n        this.reset = 0;\r\n        this.processing = false;\r\n        this.latencyRef = latencyRef;\r\n        this._queue = [];\r\n    }\r\n\r\n    /**\r\n    * Queue something in the SequentialBucket\r\n    * @arg {Function} func A function to call when a token can be consumed. The function will be passed a callback argument, which must be called to allow the bucket to continue to work\r\n    */\r\n    queue(func, short) {\r\n        if(short) {\r\n            this._queue.unshift(func);\r\n        } else {\r\n            this._queue.push(func);\r\n        }\r\n        this.check();\r\n    }\r\n\r\n    check(override) {\r\n        if(this._queue.length === 0) {\r\n            if(this.processing) {\r\n                clearTimeout(this.processing);\r\n                this.processing = false;\r\n            }\r\n            return;\r\n        }\r\n        if(this.processing && !override) {\r\n            return;\r\n        }\r\n        const now = Date.now();\r\n        const offset = this.latencyRef.latency + (this.latencyRef.offset || 0);\r\n        if(!this.reset) {\r\n            this.reset = now - offset;\r\n            this.remaining = this.limit;\r\n        } else if(this.reset < now - offset) {\r\n            this.reset = now - offset + (this.resetInterval || 0);\r\n            this.remaining = this.limit;\r\n        }\r\n        this.last = now;\r\n        if(this.remaining <= 0) {\r\n            this.processing = setTimeout(() => {\r\n                this.processing = false;\r\n                this.check(true);\r\n            }, Math.max(0, (this.reset || 0) - now) + offset);\r\n            return;\r\n        }\r\n        --this.remaining;\r\n        this.processing = true;\r\n        this._queue.shift()(() => {\r\n            if(this._queue.length > 0) {\r\n                this.check(true);\r\n            } else {\r\n                this.processing = false;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nmodule.exports = SequentialBucket;\r\n"]},"metadata":{},"sourceType":"script"}